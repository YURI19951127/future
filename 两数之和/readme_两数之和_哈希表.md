# 哈希表
## 思路及算法
注意到方法一的时间复杂度较高的原因是寻找`target - x`的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。

使用哈希表，可以将寻找 `target - x` 的时间复杂度降低到从 __*O(N)*__ 降低到 __*O*(1)__。

这样我们创建一个哈希表，对于每一个 `x`，我们首先查询哈希表中是否存在 `target - x`，然后将 `x` 插入到哈希表中，即可保证不会让 `x` 和自己匹配。

## 代码详解
    hashtable = dict()
创建一个名为hashtable的空字典

    for i, num in enumerate(nums):
__enumerate()__ 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。此时i, num为nums的初始索引和元素

    hashtable[nums[i]] = i
字典的填充方式，第一遍循环后，hashtable由空集{}变为{2：0}，之后依次填充

##复杂度分析
* 时间复杂度：*O(N)*，其中 *N* 是数组中的元素数量。对于每一个元素 `x`，我们可以 *O(1)* 地寻找 `target - x`。
* 空间复杂度：*O(N)*，其中 *N* 是数组中的元素数量。主要为哈希表的开销。
